@{
    ViewData["Title"] = "T√¨m ki·∫øm AI";
    Layout = "~/Views/Shared/_LayoutV2.cshtml";
}

<link rel="stylesheet" href="~/css/AISreach.css" />

<div class="ai-search-container">
    <!-- Search Form Column -->
    <div class="search-form-column">
        <h2 class="text-2xl font-bold mb-6 text-gray-800">ü§ñ T√¨m ki·∫øm AI</h2>

        <!-- AI Recommendation -->
        <div class="ai-recommendation" id="aiRecommendation">
            <h3>üí° G·ª£i √Ω t·ª´ AI</h3>
            <p>Nh·∫≠p ti√™u ch√≠ t√¨m ki·∫øm ƒë·ªÉ nh·∫≠n g·ª£i √Ω th√¥ng minh t·ª´ AI</p>
        </div>

        <!-- Search Form -->
        <form id="aiSearchForm">
            <div class="search-form-group">
                <label for="searchLocation">üìç Khu v·ª±c t√¨m ki·∫øm</label>
                <input type="text" id="searchLocation" placeholder="VD: Qu·∫≠n 1, TP.HCM" required>
            </div>

            <div class="search-form-group">
                <label for="propertyType">üè† Lo·∫°i b·∫•t ƒë·ªông s·∫£n</label>
                <select id="propertyType">
                    <option value="">T·∫•t c·∫£ lo·∫°i</option>
                    <!-- Property types will be loaded dynamically -->
                </select>
            </div>

            <div class="search-form-group">
                <label>üí∞ M·ª©c gi√° (tri·ªáu/th√°ng)</label>
                <div class="range-slider-container">
                    <input type="range" id="minPrice" class="range-slider" min="0" max="100" value="0">
                    <input type="range" id="maxPrice" class="range-slider" min="0" max="100" value="100">
                    <div class="range-labels">
                        <span id="minPriceLabel">0 tri·ªáu</span>
                        <span id="maxPriceLabel">100 tri·ªáu</span>
                    </div>
                </div>
            </div>

            <div class="search-form-group">
                <label>üõèÔ∏è S·ªë ph√≤ng ng·ªß</label>
                <div class="range-slider-container">
                    <input type="range" id="minBedrooms" class="range-slider" min="0" max="10" value="0">
                    <input type="range" id="maxBedrooms" class="range-slider" min="0" max="10" value="10">
                    <div class="range-labels">
                        <span id="minBedroomsLabel">0 ph√≤ng</span>
                        <span id="maxBedroomsLabel">10 ph√≤ng</span>
                    </div>
                </div>
            </div>

            <div class="search-form-group">
                <label>üìê Di·ªán t√≠ch (m¬≤)</label>
                <div class="range-slider-container">
                    <input type="range" id="minArea" class="range-slider" min="0" max="500" value="0">
                    <input type="range" id="maxArea" class="range-slider" min="0" max="500" value="500">
                    <div class="range-labels">
                        <span id="minAreaLabel">0 m¬≤</span>
                        <span id="maxAreaLabel">500 m¬≤</span>
                    </div>
                </div>
            </div>

            <div class="search-form-group">
                <label>‚≠ê Ti·ªán √≠ch c·∫ßn thi·∫øt</label>
                <div class="flex flex-wrap gap-2">
                    <label class="flex items-center">
                        <input type="checkbox" value="school" class="mr-2"> Tr∆∞·ªùng h·ªçc
                    </label>
                    <label class="flex items-center">
                        <input type="checkbox" value="hospital" class="mr-2"> B·ªánh vi·ªán
                    </label>
                    <label class="flex items-center">
                        <input type="checkbox" value="supermarket" class="mr-2"> Si√™u th·ªã
                    </label>
                    <label class="flex items-center">
                        <input type="checkbox" value="restaurant" class="mr-2"> Nh√† h√†ng
                    </label>
                    <label class="flex items-center">
                        <input type="checkbox" value="bank" class="mr-2"> Ng√¢n h√†ng
                    </label>
                    <label class="flex items-center">
                        <input type="checkbox" value="park" class="mr-2"> C√¥ng vi√™n
                    </label>
                </div>
            </div>

            <button type="submit" class="search-button" id="searchButton">
                <span class="loading-spinner" id="loadingSpinner" style="display: none;"></span>
                üîç T√¨m ki·∫øm v·ªõi AI
            </button>
        </form>
    </div>

    <!-- Results Column -->
    <div class="results-column">
        <!-- AI Recommendation Display -->
        <div class="ai-recommendation-display" id="aiRecommendationDisplay" style="display: none;">
            <h3>üí° G·ª£i √Ω t·ª´ AI</h3>
            <div id="aiRecommendationContent"></div>
        </div>

        <!-- Property List -->
        <div class="property-list" id="propertyList" style="display: none;">
            <h3 class="text-lg font-semibold mb-4 text-gray-800">üè† B·∫•t ƒë·ªông s·∫£n ph√π h·ª£p</h3>
            <div id="propertyItems"></div>
        </div>
    </div>
</div>

<script src="~/js/config.js"></script>

<script>
    // Initialize page
    document.addEventListener('DOMContentLoaded', function() {
        console.log('=== AISearch.cshtml DOM Loaded ===');
        
        // Initialize directly without waiting for config
        console.log('üöÄ Initializing directly...');
        initializeForm();
        loadStoredData();
        setupRangeSliders();
        loadPropertyTypesDirect(); // Use direct method
    });

    function initializeForm() {
        const form = document.getElementById('aiSearchForm');
        const searchButton = document.getElementById('searchButton');

        // ƒê·∫£m b·∫£o loadingSpinner t·ªìn t·∫°i
        ensureLoadingSpinnerExists();

        // G·∫Øn event listener cho form submit
        form.addEventListener('submit', handleSearch);

        // G·∫Øn th√™m event listener cho button click ƒë·ªÉ ƒë·∫£m b·∫£o ho·∫°t ƒë·ªông
        searchButton.addEventListener('click', function(e) {
            e.preventDefault();
            handleSearch(e);
        });
    }

    function ensureLoadingSpinnerExists() {
        let loadingSpinner = document.getElementById('loadingSpinner');

        if (!loadingSpinner) {
            loadingSpinner = document.createElement('span');
            loadingSpinner.className = 'loading-spinner';
            loadingSpinner.id = 'loadingSpinner';
            loadingSpinner.style.display = 'none';
            loadingSpinner.style.marginRight = '5px';

            // Th√™m v√†o searchButton n·∫øu c√≥
            const searchButton = document.getElementById('searchButton');
            if (searchButton) {
                searchButton.appendChild(loadingSpinner);
            }
        }
    }

    function loadStoredData() {
        const aiSearchData = sessionStorage.getItem('aiSearchData');
        if (aiSearchData) {
            const data = JSON.parse(aiSearchData);

            if (data.keyword) {
                document.getElementById('searchLocation').value = data.keyword;
            }
            if (data.type) {
                document.getElementById('propertyType').value = data.type;
            }
            if (data.minPrice) {
                document.getElementById('minPrice').value = data.minPrice;
            }
            if (data.maxPrice) {
                document.getElementById('maxPrice').value = data.maxPrice;
            }
            if (data.minRoom) {
                document.getElementById('minBedrooms').value = data.minRoom;
            }
            if (data.maxRoom) {
                document.getElementById('maxBedrooms').value = data.maxRoom;
            }
            if (data.minArea) {
                document.getElementById('minArea').value = data.minArea;
            }
            if (data.maxArea) {
                document.getElementById('maxArea').value = data.maxArea;
            }

            updateRangeLabels();
        }
    }

    function setupRangeSliders() {
        // Price range
        const minPrice = document.getElementById('minPrice');
        const maxPrice = document.getElementById('maxPrice');

        minPrice.addEventListener('input', function() {
            if (parseInt(this.value) > parseInt(maxPrice.value)) {
                this.value = maxPrice.value;
            }
            updateRangeLabels();
        });

        maxPrice.addEventListener('input', function() {
            if (parseInt(this.value) < parseInt(minPrice.value)) {
                this.value = minPrice.value;
            }
            updateRangeLabels();
        });

        // Bedrooms range
        const minBedrooms = document.getElementById('minBedrooms');
        const maxBedrooms = document.getElementById('maxBedrooms');

        minBedrooms.addEventListener('input', function() {
            if (parseInt(this.value) > parseInt(maxBedrooms.value)) {
                this.value = maxBedrooms.value;
            }
            updateRangeLabels();
        });

        maxBedrooms.addEventListener('input', function() {
            if (parseInt(this.value) < parseInt(minBedrooms.value)) {
                this.value = minBedrooms.value;
            }
            updateRangeLabels();
        });

        // Area range
        const minArea = document.getElementById('minArea');
        const maxArea = document.getElementById('maxArea');

        minArea.addEventListener('input', function() {
            if (parseInt(this.value) > parseInt(maxArea.value)) {
                this.value = maxArea.value;
            }
            updateRangeLabels();
        });

        maxArea.addEventListener('input', function() {
            if (parseInt(this.value) < parseInt(minArea.value)) {
                this.value = minArea.value;
            }
            updateRangeLabels();
        });

        updateRangeLabels();
    }

    function updateRangeLabels() {
        document.getElementById('minPriceLabel').textContent = document.getElementById('minPrice').value + ' tri·ªáu';
        document.getElementById('maxPriceLabel').textContent = document.getElementById('maxPrice').value + ' tri·ªáu';
        document.getElementById('minBedroomsLabel').textContent = document.getElementById('minBedrooms').value + ' ph√≤ng';
        document.getElementById('maxBedroomsLabel').textContent = document.getElementById('maxBedrooms').value + ' ph√≤ng';
        document.getElementById('minAreaLabel').textContent = document.getElementById('minArea').value + ' m¬≤';
        document.getElementById('maxAreaLabel').textContent = document.getElementById('maxArea').value + ' m¬≤';
    }



    // Load property types directly with hardcoded URL
    async function loadPropertyTypesDirect() {
        try {
            console.log('üîç Loading property types directly...');
            
            const url = 'https://localhost:7031/api/PropertyType/GetAllPropertyTypes';
            console.log('üì° Direct API URL:', url);
            
            // Make API call
            console.log('üì§ Making fetch request...');
            const response = await fetch(url);
            console.log('üì• Response received:', response);
            console.log('üìä Response status:', response.status);
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const propertyTypes = await response.json();
            console.log('üìã Property types received:', propertyTypes);
            console.log('üìä Data type:', typeof propertyTypes);
            console.log('üìä Is array:', Array.isArray(propertyTypes));
            console.log('üìä Length:', propertyTypes?.length);
            
            // Get select element
            const typeSelect = document.getElementById('propertyType');
            if (!typeSelect) {
                throw new Error('Property type select element not found');
            }
            console.log('üéØ Select element found:', typeSelect);
            
            // Clear and add options
            typeSelect.innerHTML = '<option value="">T·∫•t c·∫£ lo·∫°i</option>';
            console.log('üßπ Cleared select element');
            
            if (propertyTypes && Array.isArray(propertyTypes)) {
                propertyTypes.forEach((type, index) => {
                    console.log(`‚ûï Adding option ${index + 1}:`, type);
                    const option = document.createElement('option');
                    option.value = type.name;
                    option.textContent = type.name;
                    typeSelect.appendChild(option);
                    console.log(`‚úÖ Added option: ${type.name}`);
                });
                console.log(`üéâ Successfully loaded ${propertyTypes.length} property types directly`);
                
                // Verify final state
                console.log('üîç Final select options count:', typeSelect.options.length);
                console.log('üîç Final select innerHTML length:', typeSelect.innerHTML.length);
            } else {
                throw new Error('Invalid property types data format');
            }
            
        } catch (error) {
            console.error('‚ùå Error loading property types directly:', error.message);
            console.error('‚ùå Full error:', error);
            
            const typeSelect = document.getElementById('propertyType');
            if (typeSelect) {
                typeSelect.innerHTML = '<option value="">Kh√¥ng th·ªÉ t·∫£i lo·∫°i</option>';
                console.log('‚ö†Ô∏è Set error message in select');
            }
        }
    }

    async function handleSearch(e) {
        e.preventDefault();

        const searchButton = document.getElementById('searchButton');
        let loadingSpinner = document.getElementById('loadingSpinner');

        // Ki·ªÉm tra elements c√≥ t·ªìn t·∫°i kh√¥ng
        if (!searchButton) {
            console.error('Search button not found!');
            return;
        }

        // T·∫°o loadingSpinner ƒë·ªông n·∫øu kh√¥ng t·ªìn t·∫°i
        if (!loadingSpinner) {
            console.warn('Loading spinner not found, creating dynamic one...');
            loadingSpinner = document.createElement('span');
            loadingSpinner.className = 'loading-spinner';
            loadingSpinner.id = 'loadingSpinner';
            loadingSpinner.style.display = 'inline-block';
            loadingSpinner.style.marginRight = '5px';
        }

        // Show loading
        searchButton.disabled = true;
        loadingSpinner.style.display = 'inline-block';
        searchButton.innerHTML = '';
        searchButton.appendChild(loadingSpinner);
        searchButton.appendChild(document.createTextNode('ƒêang t√¨m ki·∫øm...'));

        try {
            const searchData = {
                searchLocation: document.getElementById('searchLocation').value,
                propertyType: document.getElementById('propertyType').value,
                minPrice: parseInt(document.getElementById('minPrice').value),
                maxPrice: parseInt(document.getElementById('maxPrice').value),
                minBedrooms: parseInt(document.getElementById('minBedrooms').value),
                maxBedrooms: parseInt(document.getElementById('maxBedrooms').value),
                minArea: parseInt(document.getElementById('minArea').value),
                maxArea: parseInt(document.getElementById('maxArea').value),
                maxResults: 100,
                requiredAmenities: getSelectedAmenities()
            };

            // Call AI Recommendation API - S·ª≠ d·ª•ng URL tr·ª±c ti·∫øp
            const response = await fetch('https://localhost:7031/api/AIRecommendation/search-by-criteria', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(searchData)
            });

            if (!response.ok) {
                throw new Error('Kh√¥ng th·ªÉ t√¨m ki·∫øm');
            }

            const result = await response.json();

            // Debug: Log k·∫øt qu·∫£ t·ª´ API
            console.log('=== API RESPONSE DEBUG ===');
            console.log('Total properties:', result.properties?.length);
            console.log('Properties:', result.properties);
            console.log('========================');

            // Update AI recommendation
            updateAIRecommendation(result.recommendationReason);

            // Display properties with full result data
            displayProperties(result.properties, result);

        } catch (error) {
            console.error('L·ªói t√¨m ki·∫øm:', error);
            alert('C√≥ l·ªói x·∫£y ra khi t√¨m ki·∫øm: ' + error.message);
        } finally {
            // Hide loading - ki·ªÉm tra elements tr∆∞·ªõc khi s·ª≠ d·ª•ng
            if (searchButton) {
                searchButton.disabled = false;
                searchButton.innerHTML = 'üîç T√¨m ki·∫øm v·ªõi AI';
            }
        }
    }

    function getSelectedAmenities() {
        const checkboxes = document.querySelectorAll('input[type="checkbox"]:checked');
        return Array.from(checkboxes).map(cb => cb.value);
    }

    function updateAIRecommendation(reason) {
        const aiRecommendationDisplay = document.getElementById('aiRecommendationDisplay');
        const aiRecommendationContent = document.getElementById('aiRecommendationContent');

        aiRecommendationContent.innerHTML = `<p>${reason}</p>`;
        aiRecommendationDisplay.style.display = 'block';
    }

    function displayProperties(properties, result) {
        const propertyList = document.getElementById('propertyList');
        const propertyItems = document.getElementById('propertyItems');

        // X√≥a d·ªØ li·ªáu c≈© tr∆∞·ªõc khi hi·ªÉn th·ªã m·ªõi
        propertyItems.innerHTML = '';

        if (!properties || properties.length === 0) {
            propertyItems.innerHTML = '<p class="text-gray-500">Kh√¥ng t√¨m th·∫•y b·∫•t ƒë·ªông s·∫£n ph√π h·ª£p</p>';
        } else {
            let html = '';
            properties.forEach(property => {
                // T√≠nh ƒëi·ªÉm ph√π h·ª£p theo m√†u s·∫Øc
                const scoreColor = getScoreColor(property.matchScore);
                const scoreText = property.matchScore ? `${property.matchScore.toFixed(1)}/100` : 'N/A';

                html += `
                    <div class="property-item">
                        <div class="property-header">
                            <div class="property-title">
                                <a href="/Home/PropertyDetail/${property.id}" class="property-title-link" target="_blank">
                                    ${property.title}
                                </a>
                            </div>
                            <div class="property-score" style="background-color: ${scoreColor}">
                                ${scoreText}
                            </div>
                        </div>
                        <div class="property-details">
                            <span class="property-type">${property.type}</span>
                            <span class="property-bedrooms">${property.bedrooms} ph√≤ng ng·ªß</span>
                            <span class="property-area">${property.area}m¬≤</span>
                        </div>
                        <div class="property-price">${formatPrice(property.price)}/th√°ng</div>
                        <div class="property-location">
                            <span class="property-address">${property.province} ‚Ä¢ ${property.ward}</span>
                            <span class="property-distance">C√°ch ${property.distanceKm.toFixed(1)}km</span>
                        </div>
                        ${property.matchReason ? `<div class="property-reason">${property.matchReason}</div>` : ''}
                        ${property.amenities && property.amenities.length > 0 ?
                            `<div class="property-amenities">
                                <span class="amenities-label">Ti·ªán √≠ch:</span>
                                ${property.amenities.slice(0, 3).join(', ')}
                                ${property.amenities.length > 3 ? ` +${property.amenities.length - 3} kh√°c` : ''}
                            </div>` : ''
                        }
                    </div>
                `;
            });

            propertyItems.innerHTML = html;
        }

        propertyList.style.display = 'block';
    }

    function getScoreColor(score) {
        if (!score) return '#6b7280'; // Gray for N/A

        if (score >= 90) return '#059669'; // Green for excellent
        if (score >= 80) return '#0d9488'; // Teal for very good
        if (score >= 70) return '#0891b2'; // Blue for good
        if (score >= 60) return '#f59e0b'; // Yellow for fair
        return '#dc2626'; // Red for poor
    }

    function formatPrice(price) {
        // Gi√° t·ª´ API l√† VND, chuy·ªÉn v·ªÅ tri·ªáu VND
        if (price >= 1000000) {
            return (price / 1000000).toFixed(1) + ' tri·ªáu';
        } else if (price >= 1000) {
            return (price / 1000).toFixed(1) + ' ngh√¨n';
        }
        return price + ' VND';
    }
</script>

